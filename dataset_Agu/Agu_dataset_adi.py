import math
import random
import subprocess
import requests
import re
import os
from prompt import *
from typing import List
from optimization_table import optimization_table
from bug_table import bug_table
from typing import Dict, List
import shutil
from lib_function import *
from llm_api import *
global_list = []

def random_subset(lst):
    """Return a random non-empty subset of lst."""
    subset = [x for x in lst if random.choice([True, False])]
    if not subset:
        subset = [random.choice(lst)]
    return subset

class Node:
    def __init__(self, state, parent=None):
        self.state = state        # The current prompt state
        self.parent = parent      # Parent node
        self.children = []        # List of child nodes
        self.visits = 0           # Number of times node has been visited
        self.value = 0            # Total value of simulations from this node

    def is_fully_expanded(self):
        # A node is fully expanded if there are no remaining moves.
        return len(self.state.get_possible_moves()) == 0
    
    def best_child(self, exploration_weight=0.1):
        return max(
            self.children,
            key=lambda child: child.value +
            exploration_weight * math.sqrt(math.log(self.visits + 1) / (child.visits + 1e-6))
        )
    
    def expand(self):
        possible_moves = self.state.get_possible_moves()
        flattened_moves = flatten(possible_moves)
        print("expand possible move: ",flattened_moves)
        #for move in flattened_moves:
        new_state = self.state.generate_new_prompt(flattened_moves)
        print("flattened_moves: ",flattened_moves)
        if not any(child.state.current_prompt == new_state.current_prompt for child in self.children):
            child_node = Node(new_state, parent=self)
            self.children.append(child_node)
            return child_node
        return None
    
    def backpropagate(self, result):
        self.visits += 1
        self.value += result
        if self.parent:
            self.parent.backpropagate(result)

def Apply_opt(root, top_function, iterations=1000):
    for _ in range(iterations):
        node = root
        while node.children and not node.is_fully_expanded():
            node = node.best_child()
        new_node = node.expand()
        if new_node:
            node = new_node
        result = simulate(node.state,top_function)
        node.backpropagate(result)
    return root.best_child(exploration_weight=0)

def simulate(state,top_function):
    """Evaluate the prompt state."""
    return state.evaluate_prompt(top_function)

###############################################
# PromptState Definition
###############################################
class PromptState:
    def __init__(self, current_prompt, optimization_table, selected_strategies=None):
        self.current_prompt = current_prompt
        self.optimization_table = optimization_table
        self.selected_strategies = selected_strategies if selected_strategies is not None else []
        # Hold previous code generated by Deepseek-R1 (initially empty).
        code_path = f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/polybench/{top_function}/{top_function}_slow.c"
        self.previous_code = read_code_path(code_path)

    def generate_prompt_from_strategies_for(self, strategies):
        if not strategies:
            return "Optimize code for performance."
        explanations = []
        code_path = f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/polybench/{top_function}/{top_function}_slow.c"
        function_name = extract_top_function_line(code_path, top_function)
        examples = []
        for strat in strategies:
            details = self.optimization_table.get(strat, {})
            explanation = details.get("Explanation", "")
            Type = details.get("Type", "")
            baseline = details.get("Example", {}).get("Baseline", "")
            example = details.get("Example", {}).get("Optimized", "")
            explanations.append(f"- {strat}: {explanation}")
            explanations.append(f"Baseline: {baseline}")
            explanations.append(f"Optimized: {example}")
        prompt = f'''You are a FPGA engineer, You should obey Xilinx HLS code guidelines. The name of top_function is {function_name} and their ports can not be changed
                    The code should have a header(h) file named {top_function}.h and a cpp file named {top_function}.cpp The defination of variables, constants and functions are only in header file.
                    In cpp file, you should firstly give sub functions of code, the codes of top function should be at the end of cpp file.
                    Your aim is to make sure the function of code is right and the pipeline interval from Xilinx HLS log to be one to achieve better performance.
                    You should optimize the following HLS code using these strategies:\n\n''' + "\n".join(explanations)      
        print(prompt)
        #if examples:
            #prompt += "\n\nExamples:\n\n" + "\n\n".join(examples)
        return prompt

    def get_possible_moves(self):
        all_keys = set(self.optimization_table.keys())
        remaining = list(all_keys - set(self.selected_strategies))
        if not remaining:
            return []
        candidate_moves = []
        if len(self.selected_strategies):
            candidate_moves.append(self.selected_strategies) 
        move = random.choice(remaining)
        print("possible move:",move)
        if move not in candidate_moves:
            candidate_moves.append(move)
        print(len(candidate_moves))
        for move in candidate_moves:
            print(move)
        return candidate_moves

    def generate_new_prompt(self, new_strategies):
        new_selected = new_strategies
        new_selected = list(dict.fromkeys(new_selected))
        new_prompt = self.generate_prompt_from_strategies_for(new_selected)
        return PromptState(new_prompt, self.optimization_table, new_selected)

    def evaluate_prompt(self, top_function):
        # Refresh the prompt string.
        self.current_prompt = self.generate_prompt_from_strategies_for(self.selected_strategies)
        # Build full prompt: include previous code if available.
        full_prompt = self.current_prompt
        code_path = f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/{top_function}.cpp"
        if os.path.exists(code_path):
            old_code = read_code_path(code_path)
        else:
            old_code = self.previous_code
        full_prompt += f"\n\nThe previous code is:\n\n{old_code}"
        # Step 1: Generate code using Deepseek-R1.
        generated_result = deepseek_R1(full_prompt)
        print("generate_result cpp: ", generated_result['cpp'])
        print("generate_result header: ", generated_result['header'])
        if not os.path.exists(f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/"):
            os.makedirs(f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/")
        with open(f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/{top_function}.cpp", "w") as f:
            f.write(generated_result['cpp'])
        with open(f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/{top_function}.h", "w") as f:
            f.write(generated_result['header']) 

        command2 = ["cp",f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/polybench/{top_function}/{top_function}_tb.c", f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/"]
        subprocess.run(command2)
        print("Generated Code from Deepseek-R1:")
        # Step 2: Run Vitis on the generated code.
        print("global_list: ",global_list)      
        Q = self.run_vitis(top_function, full_prompt)
        # Step 3: Compute complexity penalty.
        C = 1 / len(self.current_prompt) if self.current_prompt else 0
        score = Q + C
        print("Evaluating Prompt:\n")
        print("Score:", score, "\n")
        return score

    def run_vitis(self, top_function, prompt):
        global global_list
        true_path = f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/true/"
        if os.path.exists(true_path):
            global_list = grasp_latency(true_path)
        # Generate the TCL script
        tcl_template = f"""open_project {top_function}
add_files /home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/{top_function}.cpp
set_top {top_function}
open_solution solution1
create_clock -period 5 -name default
set_part {{xcu55c-fsvh2892-2L-e}}
csynth_design
exit
"""
        import subprocess
        import re
        output_file = f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/run_hls.tcl"
    
        # Save the script to a file
        with open(output_file, "w") as file:
            file.write(tcl_template)
        print(f"TCL script generated and saved to {output_file}")

        # Run the generated TCL script using Vitis HLS
        log_file = f"{top_function}.log"
        command = ["vitis_hls", "-f", output_file]

        attempts = 0


        # Repair syn error
        error_history = []
        while attempts < 3:
            output_path = f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/a.out"
            # if os.path.exists(output_path):
            #     subprocess.run(["rm", "-f", output_path])
            function_errors = compile_and_check(f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/{top_function}.h", f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/{top_function}.cpp", f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/{top_function}_tb.c", f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/a.out")
            if not function_errors:
                try:
                    with open(log_file, "w") as log:
                        subprocess.run(command, stdout=log, stderr=log, timeout=900)  # 900秒 = 15分钟
                    print(f"Vitis HLS run completed. Logs are saved to {log_file}")
                    error_pattern = re.compile(r"ERROR: .*")
                    with open(log_file, "r") as log:
                        errors = error_pattern.findall(log.read())
                except subprocess.TimeoutExpired:
                    print("Vitis HLS execution timed out after 10 minutes. Process terminated.")
                    error_timeout = "Vitis HLS execution timed out, please reduce the parameter of unroll factor and local buffer size, simplify the code."
                    error_history.append(error_timeout)
                    errors = error_timeout
            else:
                errors = str(function_errors)

            non_one_final_ii = []
            # Extract ERROR messages from the log
            error_debug = []
            if errors:
                print("Captured ERROR messages:")
                if errors:
                    for error in errors:
                        error_history.append(error)
                        bug_key = None
                        # Iterate through each bug_table key and check if the error code is present in the message
                        for key in bug_table:
                            # Extract the numeric error code from the key (e.g., "207-3325")
                            error_code = key.split("_")[1]
                            if error_code in error:
                                bug_key = key
                                break
                        if bug_key is not None:
                            bug_entry = bug_table[bug_key]
                            debug_info = {
                                "how_to_correct": bug_entry["how_to_correct"],
                                "example_error_code": bug_entry["Example"]["ERROR code"],
                                "example_corrected_code": bug_entry["Example"]["right code"]
                            }
                            error_debug.append(debug_info)

                code_path = f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/{top_function}.cpp"
                code_header = f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/{top_function}.h"        
                # Read the header file
                if attempts > 1:
                    if os.path.exists(code_header) and os.path.exists(code_path):
                        with open(code_header, 'r') as header_file:
                            header_content = header_file.read()
                        with open(code_path, 'r') as code_file:
                            code_content = code_file.read()
                        combined_content = header_content + "\n" + code_content
                else:
                    combined_content = self.previous_code
                new_prompt = f''' The previous code is {combined_content}.
And generate new code to avoid the following errors:\n\n''' + f"the errors of previous code: {errors}" + \
             "\nYou can refer to these guidelines to correct the code:\n\n" + \
             "\n".join(str(item) for item in error_debug) + "\n\n" + "Check the error position, to repair the code ."
                print(new_prompt)
                generated_result = deepseek_R1(new_prompt)
                print("generate_result cpp: ", generated_result['cpp'])
                print("generate_result header: ", generated_result['header'])
                with open(f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/{top_function}.cpp", "w") as f:
                    f.write(generated_result['cpp'])
                with open(f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate/{top_function}.h", "w") as f:
                    f.write(generated_result['header']) 
                attempts += 1
                print(f"Vitis run error on attempt {attempts+1}. Regenerating code using deepseek_R1 with current prompt.")

            else:
                #summary = parse_hls_report_with_checks(log_file)
                print("No ERROR messages found in the log.")
                break


        if not errors:
            # Parse the log file to know performance
            non_one_final_ii = find_non_one_final_ii(log_file)
            previous_log = f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/polybench/{top_function}/{top_function}/solution1/syn/report/csynth.rpt"
            curr_log = f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/Agu_dataset/{top_function}/solution1/syn/report/csynth.rpt"
            reward = 0
            if os.path.exists(previous_log):
                result_previous = parse_hls_report_with_checks(previous_log)
                result_current = parse_hls_report_with_checks(curr_log)
                print("result_previous: ", result_previous["total_latency_cycles"])
                print("result_current: ", result_current["total_latency_cycles"])
                print("resource_constraint_met: ", result_current["resource_constraint_met"])
                if not os.path.exists(f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/true/"):
                    os.makedirs(f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/true/")
                if result_current["total_latency_cycles"] != '-':
                    if int(result_previous["total_latency_cycles"]) > int(result_current["total_latency_cycles"]) and result_current["resource_constraint_met"] == True and not int(result_current["total_latency_cycles"]) in global_list:
                        if all(int(result_current["total_latency_cycles"]) > int(value) for value in global_list):
                            reward = 2
                        global_list.append(int(result_current["total_latency_cycles"]))
                        print("New dataset: ")
                        copy_directory(f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate", f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/true/", curr_log)
                    else:
                        reward = 0
        else:
            command = ["rm", "-rf", f"/home/zqy/LLM4CHIP/dataset/pair_slow_fast/SYN_dataset/{top_function}/generate"]

        if errors:
            return -2
        elif reward:
            return reward
        else:
            return 1
###############################################
# Main Execution
###############################################
if __name__ == '__main__':
    initial_prompt = "You are a FPGA engineer, You should obey Xilinx HLS code guidelines. You should optimize the following HLS code."
    top_function = "adi"
    root_state = PromptState(initial_prompt, optimization_table)
    best_node = Apply_opt(Node(root_state), top_function, iterations=100)
    
    print("\nBest prompt found:")
    print(best_node.state.current_prompt)
    print("Final evaluation score:", best_node.state.evaluate_prompt(top_function))
